## 문제1. 빈도 기반 정렬 (Map, Priority Queue 활용)

자연수로 이루어진 배열 nums가 주어진다.
각 숫자의 등장 빈도에 따라 내림차순으로 정렬하라.
단, 빈도가 같다면 숫자가 작은 것이 앞에 오도록 정렬해야 한다.

### 입력
- nums: 1 <= nums.length <= 100,000
- nums[i]는 1 <= nums[i] <= 10^5 범위를 가진다.

### 출력
- 정렬된 배열을 반환한다.

### 예제1
```
입력: nums = [4, 1, 1, 2, 2, 2, 3, 3]
출력: [2, 2, 2, 1, 1, 3, 3, 4]
```

### 예제2
```
입력: nums = [7, 7, 7, 8, 8, 9]
출력: [7, 7, 7, 8, 8, 9]
```

### 힌트
- HashMap을 사용하여 빈도를 저장한다.
- PriorityQueue(최소 힙) 또는 TreeMap을 사용하여 빈도 기반 정렬을 수행한다.

## 문제2. 괄호 문자열 검사 (Stack 활용)

다음과 같은 괄호 종류가 포함된 문자열 s가 주어진다.
문자열이 올바른 괄호 문자열인지 검사하는 프로그램을 작성하라.

### 괄호 종류
- (), {}, []

문자열이 올바른 괄호 문자열이 되려면
1. 여는 괄호((, {, [)가 나오면 닫는 괄호(), }, ])가 적절한 순서로 나와야 한다.
2. 중첩된 괄호가 올바르게 배치되어야 한다.

### 입력
- s: 1 <= s.length <= 10^5
- s는 괄호 문자로만 이루어진다.

### 출력
- 올바른 괄호 문자열이면 "YES"를 반환하고, 그렇지 않으면 "NO"를 반환한다.

### 예제1
```
입력: s = "{[()]}"
출력: "YES"
```

### 예제2

```
입력: s = "{[(])}"
출력: "NO"
```

### 예제3

```
입력: s = "{{[[(())]]}}"
출력: "YES"
```

### 힌트
- Stack을 사용하여 여는 괄호를 저장한다.
- 닫는 괄호가 나올 때 스택의 pop() 값과 비교한다.

## 문제3. 슬라이딩 윈도우 최대값 (Deque 활용)

배열 nums와 정수 k가 주어질 때,
배열에서 크기가 k인 슬라이딩 윈도우를 움직이며 최대값을 구하라.

### 입력
- nums: 1 <= nums.length <= 100,000
- k: 1 <= k <= nums.length
- nums[i]는 -10^4 <= nums[i] <= 10^4 범위를 가진다.

### 출력
- k 길이의 슬라이딩 윈도우의 최대값들을 반환한다.

### 예제1

```
입력: nums = [1,3,-1,-3,5,3,6,7], k = 3
출력: [3,3,5,5,6,7]
```

- 슬라이딩 윈도우 [1,3,-1] → 최대값 3
- 슬라이딩 윈도우 [3,-1,-3] → 최대값 3
- 슬라이딩 윈도우 [-1,-3,5] → 최대값 5
- 슬라이딩 윈도우 [-3,5,3] → 최대값 5
- 슬라이딩 윈도우 [5,3,6] → 최대값 6
- 슬라이딩 윈도우 [3,6,7] → 최대값 7

### 예제2

```
입력: nums = [9, 11, 8, 5, 7, 10], k = 2
출력: [11, 11, 8, 7, 10]
```

### 힌트
- Deque (LinkedList)를 사용하여 O(n) 시간복잡도로 해결 가능하다.
- 단순한 배열 탐색 O(n*k)는 시간 초과가 발생할 수 있다.