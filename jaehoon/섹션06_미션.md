## 요세푸스 문제 (Josephus Problem)

n명의 사람이 원형으로 배치되어 있으며, 처음부터 순서대로 카운팅을 시작합니다. 매 k번째 사람을 제거하고, 제거된 후에는 바로 다음 사람부터 다시 카운팅을 시작합니다. 이 과정을 반복하여 최종적으로 한 사람이 남게 됩니다. 남은 사람의 번호를 출력하는 프로그램을 작성하십시오.

### 요구사항
1. 입력: 두 개의 정수 n(전체 인원)과 k(제거 간격)을 입력받습니다.
2. 초기화: 1부터 n까지의 정수를 요소로 갖는 List를 초기화합니다.
3. 시물레이션
  - 원형 구조를 고려하여, 매 k번째 사람을 제거하는 알고리즘을 구현합니다.
  - 원형 순회 시 인덱스 계산을 위해 모듈로 연산(%)을 활용하십시오.
4. 출력: 마지막에 남은 사람의 번호를 출력합니다.
5. 구현: 동일한 문제를 ArrayList와 LinkedList를 이용하여 각각 구현합니다.
6. 성능 분석
  - ArrayList의 경우, 임의 위치에서 요소를 제거할 때 발생하는 시프트 연산으로 인한 O(n) 비용(물론 고속복사를 이용)과, LinkedList의 경우 노드 탐색 비용을 고려하여 각 구현의 시간 복잡도를 분석하십시오.
  - 두 자료구조의 장단점을 이론적 분석 및 (가능하다면) 실험적 결과를 통해 비교 설명합니다.

### 알고리즘적 고려사항
- 원형 순회: 제거 후 다음 인덱스 계산 시, 리스트의 크기가 줄어들기 때문에 모듈로 연산을 통해 순환 구조를 유지합니다.
- ArrayList vs. LinkedList
  - ArrayList: 임의 인덱스 접근은 O(1)이지만, 요소 제거 시 인접 요소들의 시프트가 발생하여 O(n)의 시간 복잡도를 가집니다.
  - LinkedList: 요소 제거가 O(1)로 효율적일 수 있으나, 원하는 위치까지의 탐색이 O(n)이므로 전체적으로 유사한 시간 복잡도를 보일 수 있습니다.

### 주의
해당 문제는 여러분이 창조하는 문제가 아닌 이슈에 적힌 문제를 푸는 문제입니다!

### 예시
n을 10만 이상, k를 3혹은 5로 하면 확연한 차이를 볼 수 있을 겁니다.

## 문제풀이

### 성능분석
```
N = 100000
K = 5
최종 생존자: 40333
ArrayList 실행 시간: 239ms
최종 생존자: 40333
LinkedList 실행 시간: 2144ms
```

#### ArrayList - O(N)
- K번째 요소를 찾는 것은 O(1) (인덱스로 바로 접근 가능).
- 하지만 K번째 요소를 제거하면, 이후의 모든 요소를 한 칸씩 앞으로 이동해야 하므로 O(N) 의 시간 복잡도 발생.
- 연속된 메모리 공간에 저장되므로 캐시 히트율이 높고, 시스템의 고속 복사 최적화 덕분에 연산 속도가 빠를 수 있음.

#### LinkedList - O(N)
- K번째 요소를 찾기 위해 맨 처음 노드부터 순차적으로 탐색해야 하므로 O(N) 발생.
- 하지만 K번째 요소를 제거할 때는 연결만 끊어주면 되므로 O(1) 의 시간 복잡도를 가짐.
- K번째 요소가 맨 앞이나 맨 뒤에 있을 경우 속도가 다소 개선될 수 있으나,
- 순차 탐색이 최적화되지 않으므로 전체적으로 ArrayList보다 느릴 가능성이 큼.

#### 결론
- 데이터 크기가 작다면 (n < 10000), ArrayList가 더 빠를 수 있음. - 고속 복사때문에 왠만하면 LinkedList 보다 빠름
- 데이터 크기가 크다면 (n > 100000), LinkedList가 상대적으로 유리할 수 있으나, 데이터가 중간에 있다면 순차 탐색으로 인해 여전히 느릴 수 있음.
- 빠른 탐색과 삭제를 원한다면 LinkedList + Iterator를 사용하는 것이 가장 효율적.